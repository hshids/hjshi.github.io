---
title: " Bayesian Statistics"
date: "`r Sys.Date()`"
author: "HJ. S."
output:
  rmdformats::downcute:
    code_folding: show
    self_contained: true
    thumbnails: false
    lightbox: true
pkgdown:
  as_is: true
---

# 贝叶斯统计（Bayesian Statistics）定义

贝叶斯统计是一种统计学方法，它基于贝叶斯定理，用于更新随着证据累积而变化的概率估计。与频率主义统计不同，贝叶斯统计将概率视为不确定性的度量，并允许在分析中使用先验知识。

- **核心**：贝叶斯定理，它描述了先验概率（先验信念）如何通过新的证据（数据）更新为后验概率。

- **公式**：
  - \( P(\theta | \text{data}) = \frac{P(\text{data} | \theta) \times P(\theta)}{P(\text{data})} \)
  - 其中 \( P(\theta | \text{data}) \) 是后验概率，\( P(\text{data} | \theta) \) 是似然，\( P(\theta) \) 是先验概率。

### 故事：霍格沃茨的魔法石猜想

在霍格沃茨，有一个关于魔法石的古老传说。据说，魔法石被藏在学校的某个秘密房间里。教授们对这个传说的真实性持怀疑态度，但一些学生坚信它的存在。

#### 教授的先验信念

教授们基于历史记载和逻辑推理，认为找到魔法石的可能性非常低（低先验概率）。

#### 新证据出现

然而，在一次考古发掘中，学生们发现了一张古老的地图，上面标记着一个神秘的房间。

#### 更新信念：贝叶斯更新

教授们用贝叶斯统计来更新他们关于魔法石存在的信念。他们考虑了新的证据（地图）对原有信念的影响。

- **似然**：地图的出现显著增加了魔法石存在的可能性。
- **后验概率**：结合先验信念和新的证据，教授们更新了他们对魔法石存在可能性的估计，后验概率变得更高。

#### 结论

最终，虽然没有找到确凿的证据证明魔法石的存在，但通过贝叶斯方法，教授们对魔法石可能真实存在的信念有所增强。

### 实践中的应用

在现实世界的应用中，贝叶斯统计可以用于处理各种不确定性问题，包括疾病诊断、风险评估和机器学习。它允许我们将先验知识与新数据结合起来，形成对问题的全面理解。

贝叶斯统计的一个关键优势是其灵活性和包容性，能够在分析中考虑到不确定性和主观判断。然而，选择合适的先验和正确解释后验概率需要专业知识和实践经验。

# 贝叶斯统计进阶

继续深入理解贝叶斯统计之后，你可以探索更多与贝叶斯方法相关的高级主题和应用领域。以下是一些建议的后续学习方向：

## 高级贝叶斯方法

1. **贝叶斯网络（Bayesian Networks）**:
   - 学习如何使用贝叶斯网络建模复杂的概率关系，尤其在存在不确定性和条件依赖时。

2. **MCMC（Markov Chain Monte Carlo）方法**:
   - 理解并应用MCMC方法进行复杂后验分布的抽样，这在计算后验概率分布时非常有用。

3. **贝叶斯层次模型（Hierarchical Bayesian Models）**:
   - 探索如何在数据具有自然层次结构时应用贝叶斯方法。

4. **贝叶斯模型比较**:
   - 学习如何比较不同贝叶斯模型的优劣，包括使用贝叶斯因子（Bayes Factor）。

## 应用领域

1. **机器学习和数据科学**:
   - 贝叶斯方法在机器学习领域有广泛应用，包括分类、回归和聚类等任务。

2. **生物统计学和流行病学**:
   - 在医学研究中，贝叶斯统计用于药物试验、疾病风险评估和基因数据分析。

3. **金融模型**:
   - 在金融市场分析和风险管理中应用贝叶斯方法进行预测和决策。

## 工具和技术

- **R和Python中的贝叶斯分析包**:
  - 学习如何使用如Stan、JAGS、PyMC3等工具进行贝叶斯分析。

- **实际案例研究**:
  - 通过分析真实数据集来应用和巩固贝叶斯统计的知识。

# 贝叶斯网络（Bayesian Networks）定义

贝叶斯网络，也称为信念网络或因果网络，是一种图形模型，用于表示变量间的概率关系。它由节点（代表随机变量）和有向边（代表这些变量之间的依赖关系）组成。贝叶斯网络使我们能够进行复杂的概率推理和决策。

## 贝叶斯网络的关键特点

- **因果关系:**
  - 节点间的边代表因果关系或影响。
  
- **条件概率:**
  - 每个节点都有一个条件概率表，它定义了在给定其父节点状态下该节点状态的概率。

- **推理:**
  - 贝叶斯网络支持基于新证据更新信念的推理过程。

## 贝叶斯与霍格沃茨密室

### 背景
霍格沃茨学校陷入了密室事件的恐慌中。几位学生和图书馆管理员的猫神秘消失了。校方希望使用贝叶斯网络来揭示背后的真相。

### 构建贝叶斯网络
教授们构建了一个贝叶斯网络来表示不同因素之间的概率关系。网络中的节点包括：

- **学生活动（如上课、在图书馆等）**
- **目击证言（如听到奇怪的声音、看到可疑人物）**
- **密室相关证据（如密室的开启、怪异的蛇形符号）**
- **消失事件（学生和猫的失踪）**

### 收集证据
- 图书馆管理员报告说在失踪前夜听到了低语。
- 部分学生称在图书馆附近看到了蛇形符号。

### 使用贝叶斯网络进行推理
- 教授们输入了上述证据到网络中。
- 网络分析显示，在某些特定条件下，密室的存在与消失事件之间存在较高的概率联系。

### R语言实现 
这里我们用R语言简化地模拟构建这样一个贝叶斯网络。

```{r}
# 安装和加载bnlearn包
if (!require("bnlearn")) install.packages("bnlearn")
library(bnlearn)
```

我们首先创建了一个包含所有需要的节点的空网络。随后，我们使用`set.arc`函数添加了从各个因素（学生活动、目击证言和密室相关证据）到消失事件的边。

```{r}
# 创建一个空的网络
net <- empty.graph(nodes = c("StudentActivity", "Disappearance", "WitnessTestimony", "ChamberEvidence"))

# 逐步添加边来定义网络结构
net <- set.arc(net, from = "StudentActivity", to = "Disappearance")
net <- set.arc(net, from = "WitnessTestimony", to = "Disappearance")
net <- set.arc(net, from = "ChamberEvidence", to = "Disappearance")

# 查看网络结构
print(net)
```

`bnlearn`包不支持字符型（character）变量。在`bnlearn`中，节点变量通常需要是因子（factor）类型。在这段代码中，我们使用`as.factor`函数将所有字符型列转换为因子。这样，`bn.fit`函数就可以正确处理数据，并根据提供的网络结构和数据来学习网络参数。

#### **贝叶斯网络结果分析**

```{r}
# 模拟一些数据
set.seed(123)  # 为了结果的可重复性
data <- data.frame(
  StudentActivity = sample(c("Class", "Library"), 100, replace = TRUE),
  WitnessTestimony = sample(c("HeardWhispers", "HeardNothing"), 100, replace = TRUE),
  ChamberEvidence = sample(c("SawSymbols", "SawNothing"), 100, replace = TRUE),
  Disappearance = sample(c("Occurred", "NotOccurred"), 100, replace = TRUE)
)

# 学习网络的参数
# 确保所有列都是因子类型
data$StudentActivity <- as.factor(data$StudentActivity)
data$WitnessTestimony <- as.factor(data$WitnessTestimony)
data$ChamberEvidence <- as.factor(data$ChamberEvidence)
data$Disappearance <- as.factor(data$Disappearance)

# 使用转换后的数据拟合贝叶斯网络
fitted_net <- bn.fit(net, data)

print(fitted_net)

```
这段结果是关于一个贝叶斯网络（Bayesian network）的参数描述。贝叶斯网络是一种用于建模随机变量之间的依赖关系的图结构，其中节点表示随机变量，边表示它们之间的依赖关系。每个节点的参数描述了给定其父节点的条件下，该节点的概率分布。

以下是对这段结果的分析：

1. **节点 "StudentActivity" 的参数（多项分布）：**
   - 条件概率表显示了两个可能的状态 "Class" 和 "Library"，以及它们的概率分布。
   - 对于 "Class"，概率为 0.57，对于 "Library"，概率为 0.43。
   - 这表示在给定其他节点的情况下，"StudentActivity" 节点有两种可能的状态，"Class" 和 "Library"，并且这些状态的概率分布是给定的。

2. **节点 "Disappearance" 的参数（多项分布）：**
   - 这个节点的条件概率表根据两个父节点的不同状态进行了分组，父节点是 "WitnessTestimony" 和 "ChamberEvidence"。
   - 具体地，有四种可能的组合：HeardNothing & SawNothing，HeardWhispers & SawNothing，HeardNothing & SawSymbols，HeardWhispers & SawSymbols。
   - 每种组合下，都有 "Disappearance" 节点的 "NotOccurred" 和 "Occurred" 两种状态，以及它们的概率分布。

3. **节点 "WitnessTestimony" 的参数（多项分布）：**
   - 这个节点表示 "HeardNothing" 和 "HeardWhispers" 两种可能的状态，以及它们的概率分布。
   - "HeardNothing" 的概率为 0.54，"HeardWhispers" 的概率为 0.46。
   - 这表示 "WitnessTestimony" 节点的状态取决于这两种可能的状态，并且它们的概率分布是给定的。

4. **节点 "ChamberEvidence" 的参数（多项分布）：**
   - 这个节点表示 "SawNothing" 和 "SawSymbols" 两种可能的状态，以及它们的概率分布。
   - "SawNothing" 的概率为 0.49，"SawSymbols" 的概率为 0.51。
   - 这表示 "ChamberEvidence" 节点的状态取决于这两种可能的状态，并且它们的概率分布是给定的。

这些参数描述了一个复杂的贝叶斯网络，可以用于推断在不同条件下各个节点的状态的概率。这个网络的结构和参数可以用于解决特定的概率推断问题，例如根据观察到的证据来估计学生是否消失的概率。

#### **构建逻辑回归模型**

我们首先创建和拟合了贝叶斯网络。然后，我们使用逻辑回归模型来预测`Disappearance`节点的状态。最后，我们定义了一组新的观测数据，并使用`predict`函数来预测Disappearance发生的概率。

使用`predict`函数对您的贝叶斯网络进行预测，我们需要先将贝叶斯网络模型转换为一种可以应用预测模型的格式。由于`bnlearn`包并不直接支持使用`predict`函数进行预测，我们需要采取替代方法，比如使用逻辑回归。

我们可以基于贝叶斯网络结构来构建一个逻辑回归模型，以预测`Disappearance`节点的状态。请注意，这种方法实际上并不涉及使用贝叶斯网络进行预测，而是使用网络结构来指导传统的统计模型的建立。


```{r}
# 构建逻辑回归模型
model <- glm(Disappearance ~ StudentActivity + WitnessTestimony + ChamberEvidence, 
             data = data, family = binomial())
```


#### **进行预测**

```{r}
# 定义新的观测数据用于预测
new_data <- data.frame(
  StudentActivity = factor("Library", levels = c("Class", "Library")),
  WitnessTestimony = factor("HeardWhispers", levels = c("HeardWhispers", "HeardNothing")),
  ChamberEvidence = factor("SawSymbols", levels = c("SawSymbols", "SawNothing"))
)

# 使用模型进行预测
predicted_probs <- predict(model, newdata = new_data, type = "response")

# 输出预测的概率
print(predicted_probs)
```

在这个例子中，首先使用`glm`函数构建了一个逻辑回归模型，其中`Disappearance`是因变量，而`StudentActivity`、`WitnessTestimony`和`ChamberEvidence`是自变量。然后，我们定义了一组新的观测数据，并使用`predict`函数来预测`Disappearance`发生的概率。经过贝叶斯网络模型对新的观测数据进行了预测，预测的概率为 0.4693946。这个概率表示，在给定新的观测数据的情况下，学生发生消失的概率。

请注意，这种方法并不是直接使用贝叶斯网络进行预测，而是利用网络结构来指导传统统计模型的构建。

## MCMC（Markov Chain Monte Carlo）马尔可夫链

MCMC（Markov Chain Monte Carlo）是一种在统计学中使用的算法，用于从复杂的概率分布中抽取样本。在贝叶斯统计中，MCMC特别重要，因为它可以用来近似复杂后验概率分布，特别是当这些分布难以解析计算时。它特别适用于那些难以用解析方法直接计算的复杂概率分布。MCMC通过构建马尔可夫链来生成样本，这些样本的分布逐渐逼近目标概率分布，从而允许我们进行有效的近似推断。

MCMC通过构建一个马尔可夫链来工作。这个链在可能解的空间中随机“游走”，其特点是每一步的位置只依赖于前一步的位置。随着时间的推移，这个链的分布趋于稳定，从而近似目标分布（例如后验分布）。

### MCMC的关键概念

1. **马尔可夫链**:
   - 一种随机过程，当前状态只依赖于前一个状态，不依赖于更早的历史。
2. **蒙特卡罗方法**:
   - 一种利用随机抽样来近似复杂计算的方法。

### MCMC在贝叶斯统计中的应用

- **后验分布的抽样**:
  - 在贝叶斯分析中，MCMC用于从后验分布中抽取样本，特别是当这个分布难以直接计算时。
- **参数估计**:
  - MCMC方法使我们能够估计模型参数的后验分布，从而了解参数的不确定性。


### 故事： 霍格沃茨火焰杯与马尔可夫链

一年一度三强争霸赛比赛时，哈利波特需要找到特殊的药水，使他能在水下呼吸。这种药水的配方被隐藏起来，只有通过解决一系列复杂的谜题才能找到
 
**谜题的贝叶斯解读**
 
- 问题: 药水配方由多个成分组成，每个成分的正确比例是未知的。
 
- 目标: 使用MCMC来估计这些成分的最佳比例。
 
**MCMC在寻找答案中的角色**
 
- 构建马尔可夫链: 三人组通过实验和收集线索，逐步构建了一条马尔可夫链，每一步都基于前一步的信息进行调整，逐渐逼近药水的正确配方。
 
- 探索可能的解决方案: 通过MCMC，他们能够探索一系列可能的配方，每个配方都有一定的概率是正确的
 
- 找到最可能的配方: 随着时间的推移，他们发现某些配方比其他配方更可能是正确的。MCMC帮助他们确定哪些成分比例最有可能产生有效的药水。
 
**药水的成功制作**
 
最终，通过MCMC的帮助，赫敏成功地锁定了最有可能的药水配方，并让哈利波特在水下任务中成功救出芙蓉的妹妹和罗恩。

### MCMC的实际应用

在现实世界中，MCMC被广泛用于估计复杂模型的参数，特别是在贝叶斯统计学中。它允许研究人员从概率模型的后验分布中抽取样本，从而进行参数估计和预测。虽然MCMC是一种强大的工具，但它也需要仔细的设计和验证，以确保得到的样本是代表性的并且收敛于真实的后验分布。

在实际应用中，MCMC被用于各种统计模型和问题中，例如在经济学、生物统计学和机器学习等领域。它特别适合于那些后验分布难以直接计算，或者模型过于复杂无法解析求解的情况。

MCMC是一种强大但计算密集的方法，它要求仔细地选择和调整算法参数，比如步长、迭代次数等，以确保有效和准确的抽样。

### R 语言中的MCMC实现

在R中，有多个包可用于实现MCMC，如rjags、Stan和BUGS等。这些包提供了工具和函数来定义模型、执行MCMC抽样并分析结果。

我使用R语言实现MCMC的完整示例。在这个例子中，我们将使用rjags包，它是一个接口到JAGS（Just Another Gibbs Sampler）的库，JAGS是一个用于贝叶斯模型的MCMC抽样的程序。

注意！！MAC上无法install的小伙伴看过来：

Easiest way to install native arm64 jags:
brew install pkg-config jags
/Applications/RStudio.app/Contents/MacOS/RStudio
install.packages("rjags", type="source")

当然，以下是关于如何使用JAGS（Just Another Gibbs Sampler，又一个吉布斯采样器）的中文教程概述，这是一个用于贝叶斯统计中进行马尔可夫链蒙特卡洛（MCMC）模拟的程序。

### JAGS简介
JAGS是一个独立的程序，用于执行MCMC模拟。它接受贝叶斯模型描述（先验加似然）和数据作为输入，返回后验分布的MCMC样本。JAGS使用Metropolis采样、Gibbs采样和其他MCMC算法的组合。

1. **加载数据**
   - 数据可以从文件加载，或通过足够的摘要统计信息指定。例如，可以指定样本大小和成功次数。

2. **指定模型：似然和先验**
   - JAGS模型规范以`model`开始。模型提供了似然和先验的文本描述。这个文本字符串随后会传递给JAGS进行翻译。
   - 以Beta-Binomial模型为例，先验分布是Beta分布，似然函数是二项分布。

3. **在JAGS中编译模型**
   - 将模型（即文本字符串）和数据传递给JAGS进行编译。可以通过`textConnection`函数定义文本字符串。模型也可以保存在单独的文件中，文件名被传递给JAGS。数据以列表形式传递给JAGS。

4. **从后验分布中模拟值**
   - 在JAGS中模拟值分为两个步骤。首先，使用`update`命令运行模拟一个“烧入”期。然后，使用`coda.samples`从后验分布中模拟我们实际保留的值。使用`coda.samples`可以方便地使用coda包来总结和诊断MCMC模拟。

5. **总结模拟值和诊断检查**
   - 使用R的标准函数（如`summary`和`plot`）来总结`coda.samples`的结果。可以对theta的模拟值进行总结，以近似后验分布。

```{r}
if (!require("rjags")) {
    install.packages("rjags", type="source")
}
library(rjags)
```

```{r}
n = 35 # sample size
y = 31 # number of successes
```

```{r}
# 编写模型
model_string <- "model{

  # Likelihood
  y ~ dbinom(theta, n)

  # Prior
  theta ~ dbeta(alpha, beta)
  alpha <- 3 # prior successes
  beta <- 1 # prior failures

}"
```


```{r}
dataList = list(y = y, n = n)

model <- jags.model(file = textConnection(model_string), 
                    data = dataList)

```

```{r}
# 从后验分布中模拟值
update(model, n.iter = 1000) # 模拟的值的数量
```

```{r}
Nrep = 10000 # number of values to simulate

posterior_sample <- coda.samples(model,
                       variable.names = c("theta"),
                       n.iter = Nrep)
```

```{r}
summary(posterior_sample)
```

```{r}
plot(posterior_sample)
```

```{r}
thetas = as.matrix(posterior_sample)
head(thetas)
```

```{r}
hist(thetas)
```

```{r}
ynew = rbinom(Nrep, n, thetas)

plot(table(ynew),
     main = "Posterior Predictive Distribution for samples of size 35",
     xlab = "y")
```

The JAGS (Just Another Gibbs Sampler) is a program used for performing Markov Chain Monte Carlo (MCMC) simulations in Bayesian statistics. JAGS is particularly useful for Bayesian model estimation, where it takes a model description (prior and likelihood) and data to return an MCMC sample from the posterior distribution. The process involves various MCMC algorithms, including Metropolis and Gibbs sampling.

Key steps in using JAGS are:

1. **Load the Data**: Data can be loaded from a file or specified via summary statistics. An example used is a "data is singular" context with a specified sample size and number of successes.

2. **Specify the Model**: This involves writing a model statement that describes the likelihood and prior distributions. For example, in a Beta-Binomial model, you specify the Beta distribution as the prior and Binomial as the likelihood function.

3. **Compile the Model in JAGS**: The model, written as a text string, is passed to JAGS along with the data for compilation.

4. **Simulate Values from the Posterior Distribution**: After a 'burn-in' period using the `update` function, values from the posterior distribution are simulated using `coda.samples`. This step is crucial for generating the posterior samples needed for inference.

5. **Summarize Simulated Values and Check Diagnostics**: Standard functions from R (like `summary` and `plot`) are used to summarize and visually inspect the results from the MCMC simulation. This step is vital for understanding the posterior distribution and checking the convergence and other diagnostic measures of the MCMC simulation.

The section emphasizes the ease of integrating JAGS with R using the `rjags` package, allowing for a seamless workflow within the R environment. This integration is particularly beneficial for those who are already familiar with R and wish to conduct Bayesian data analysis without switching between different software environments.
